The PMOVES (POWERFULMOVES) system is an advanced, distributed multi-agent architecture designed for continuous self-improvement and research. It integrates various specialized AI and data management tools, leveraging autonomous learning, specialized knowledge, and robust workflow automation to handle complex tasks, while maintaining local control over data and models. This creates a fully local, distributed AI ecosystem.
Here's specific context for a coding agent operating within the PMOVES system:
PMOVES Core Architecture and Components
The system is structured with distinct functional layers:
• Central Brain (Primary Orchestration):
    ◦ Agent Zero acts as the core decision-maker and learning general-purpose personal assistant, orchestrating tasks across the entire network.
        ▪ It is not pre-programmed for specific tasks but gathers information, executes commands, and cooperates with other agent instances to accomplish tasks.
        ▪ Crucially, Agent Zero has persistent memory to memorize previous solutions, code, facts, and instructions for faster and more reliable future tasks.
        ▪ It can create subordinate agents to break down and solve subtasks.
        ▪ Its behavior is highly customizable through system prompts and message templates.
        ▪ Agent Zero can write its own code and use the terminal to create and use its own tools as needed.
        ▪ It includes online search as a default tool.
        ▪ Agent Zero functions as an MCP (Model Context Protocol) Server/Client, enabling communication with Archon and other agents.
        ▪ It embodies "self-learning AI agent reasoning" (UR2 principles), learning dynamic policies for knowledge acquisition and when to seek external information.
• Support Systems (Agent Building, Knowledge & Workflow):
    ◦ Archon serves as the specialized agent builder and knowledge/task management backbone for AI coding assistants. It operates as an MCP server for AI clients.
        ▪ Archon is designed as an integrated environment for all context engineering.
        ▪ It provides robust knowledge management features, including smart web crawling (for documentation sites, sitemaps, individual pages), document processing (PDFs, Word, markdown, text), and code example extraction.
        ▪ It utilizes vector search for advanced semantic retrieval and organizes knowledge by source, type, and tags.
        ▪ Archon integrates advanced RAG strategies like hybrid search, contextual embeddings, and result reranking for optimal AI responses.
        ▪ It supports hierarchical projects, features, and tasks with AI-assisted creation and real-time progress tracking.
        ▪ Archon can ingest rich metadata and structured data from other AI models, such as transcription and object detection results from the Jellyfin AI Media Stack.
    ◦ n8n is the automation and workflow orchestration layer and MCP Hub within PMOVES.
        ▪ It specifically enables MCP communication.
        ▪ Workflows in n8n facilitate multi-agent task delegation, ensuring smooth communication and coordinated action between Agent Zero instances and Archon-designed agents.
        ▪ It automates the flow of information, tasks, and results between various components.
• Specialized AI "Muscles" (Deep Processing & Generation):
    ◦ LangExtract is a core component within PMOVES for extracting structured information from unstructured text documents with precise source grounding.
        ▪ It uses LLMs (like Gemini in the Jellyfin context) for entity extraction and creates data for knowledge graphs.
        ▪ LangExtract can process documents directly from URLs and supports parallel processing for long documents.
    ◦ HiRAG (Hierarchical Retrieval-Augmented Generation) processes enriched, multi-layered knowledge from Archon to enable deeper, fact-based reasoning on complex knowledge structures.
        ▪ It builds hierarchical indices and retrieves information based on local entities, communities, and global bridges.
        ▪ This helps overcome limitations of traditional RAG like context silos and lack of explicit relationships.
    ◦ ComfyUI handles sophisticated content creation workflows, automated via n8n, for tasks like text-to-image (FLUX) and video generation (WAN2.2).
• Data & Operational Backbones:
    ◦ Supabase is the unified database with vector capabilities for the entire PMOVES system.
        ▪ It stores vector embeddings generated by Archon and HiRAG for semantic search and knowledge retrieval.
        ▪ It serves as Archon's backend for managing projects, tasks, and document metadata.
    ◦ Local Models (Ollama, NVIDIA NIM, Nemo) are a suite of LLMs distributed across the hardware network, providing the underlying language model capabilities for Agent Zero, Archon, LangExtract, and HiRAG. This ensures data privacy and efficient local processing.
• Underlying Infrastructure:
    ◦ Distributed Computing leverages various workstations (Primary, Secondary, Mobile Dev) and Edge Computing devices (Jetson Orin Nano Super x2).
    ◦ Docker is used for isolating and deploying components across this distributed infrastructure. The Jellyfin AI Media Stack, for example, is a Docker-based solution designed to align with PMOVES' distributed deployment strategy.
Autonomous Upgrading and Self-Improvement Cycle
A key goal of PMOVES is autonomous upgrading and self-improvement.
• Agent Zero, as the orchestrator, identifies tasks or areas for improvement.
• It can delegate complex research tasks to Archon-designed sub-agents.
• Archon, in turn, uses its smart web crawling and LangExtract's entity extraction capabilities to process information from sources like GitHub (for new RAG techniques or agentic features) or internal documentation.
• This extracted, structured knowledge is then refined by HiRAG to form hierarchical reasoning paths.
• Agent Zero's ability to write its own code and create tools enables it to develop and integrate new features it discovers.
• The principles of self-learning AI agent reasoning (UR2) guide LLMs to master generalizable dynamic policies for knowledge acquisition, moving beyond hardcoded logic.
• The system could potentially use "LLM as a Judge" to autonomously evaluate the effectiveness of new RAG techniques or agentic features before integration.
External Research and Integration
• Agent Zero's online search is a default tool for directly querying platforms like YouTube and GitHub.
• Archon's smart web crawling capabilities can be directed to crawl entire documentation sites and individual pages, including relevant GitHub repositories and potentially YouTube transcripts or linked documentation.
• LangExtract can process text directly from URLs to extract structured information from online resources identified by Agent Zero or Archon.

In summary, a coding agent operating within PMOVES would leverage Agent Zero for overall task orchestration and learning, Archon for specialized agent building, knowledge management, and RAG capabilities, and n8n for automating workflows and inter-agent communication, all powered by distributed local models and a unified Supabase backend, enabling a continuous cycle of research and self-improvement.

## Agent Zero MCP Runtime Integration

Agent Zero now exposes its MCP-compatible runtime to FastAPI clients, enabling HTTP workflows, WebSocket bridges, or MCP hubs to interact with the same helper commands that previously required the stdio shim.

### Runtime API Endpoints

| Endpoint | Method | Description |
| --- | --- | --- |
| `/healthz` | GET | Basic liveness probe for container orchestration. |
| `/config/environment` | GET | Returns the resolved configuration (ports, upstream services, runtime directories) with OpenAPI descriptions for each field. |
| `/mcp/commands` | GET | Lists all available MCP commands along with the active form metadata and runtime directories. |
| `/mcp/execute` | POST | Executes an MCP command; accepts `{ "cmd": "geometry.jump", "arguments": { ... } }` and returns the upstream result. |
| `/events/publish` | POST | Publishes an envelope-wrapped payload to NATS using the configured topic. |

### Environment Variables

The FastAPI OpenAPI schema documents the full configuration model; key variables include:

| Variable | Default | Purpose |
| --- | --- | --- |
| `PORT` | `8080` | HTTP port for the Agent Zero FastAPI application. |
| `NATS_URL` | `nats://nats:4222` | Connection string for publishing envelopes to the event bus. |
| `HIRAG_URL`/`GATEWAY_URL` | `http://localhost:8087` | Base URL for geometry gateway commands (fallback to `GATEWAY_URL` when `HIRAG_URL` is unset). |
| `YT_URL` | `http://localhost:8077` | YouTube ingest and transcript runtime. |
| `RENDER_WEBHOOK_URL` | `http://localhost:8085` | ComfyUI render webhook used by `comfy.render`. |
| `AGENT_FORM` | `POWERFULMOVES` | Default MCP form to load when serving metadata. |
| `AGENT_FORMS_DIR` | `configs/agents/forms` | Directory containing YAML form definitions that power MCP command palettes. |
| `AGENT_KNOWLEDGE_BASE_DIR` | `runtime/knowledge` | Local directory for Agent Zero knowledge base snapshots and embeddings. |
| `AGENT_MCP_RUNTIME_DIR` | `runtime/mcp` | Working directory for sockets, logs, or shared files used by MCP shims. |

### Operational Flow

1. On startup the FastAPI worker resolves the configuration above and connects to NATS.
2. `/config/environment` and `/mcp/commands` expose the computed runtime state so downstream systems (n8n, MCP hubs, WebSocket bridges) can introspect capabilities without shell access.
3. Clients invoke `/mcp/execute` with the desired command and payload; the service maps the request to the upstream helpers defined in `mcp_server.py` (geometry gateway, YouTube ingest, ComfyUI renderer) and streams the response back as JSON.
4. Traditional event publication continues via `/events/publish`, allowing Agent Zero to publish envelopes while simultaneously serving MCP workflows.

This integration allows platform operators to orchestrate Agent Zero entirely over HTTP, simplifying deployment behind API gateways and enabling richer monitoring through the documented configuration model.

## Archon Service Operations

### Components, Ports, and Compose Targets

Archon is deployed as a bundle of API, MCP, agent, and UI services. The PMOVES orchestration mesh exposes an `archon` profile that can be started alongside the core stack (`make up` → `make up-archon`) for a full deployment, or you can build the lightweight Archon FastAPI bridge included in this repository for NATS event publication on port `8091` (`services/archon` in `docker-compose.yml`).【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L784-L801】【F:pmoves/docker-compose.yml†L399-L409】

Upstream Archon images expose the following ports when the compose profile is enabled:

* Archon API (`archon_api`) – `8050/tcp`
* MCP HTTP server (`archon_mcp`) – `8051/tcp`
* Streaming agents (`archon_agents`) – `8053/tcp`
* React UI (`archon_ui`) – `8052/tcp` (defaults to `3000` inside the container)

These services are wired together inside `compose.archon.yml` with environment variables that point each container at the API host, Ollama/OpenAI backends, and the published MCP endpoint.【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L823-L865】 The upstream reference stack documents equivalent port assignments (UI `3737`, API `8181`, MCP `8051`, Agents `8052`) when running everything with `docker compose up --build -d` from the Archon repository.【F:docs/repoingest/coleam00-archon.txt†L523-L555】【F:docs/repoingest/coleam00-archon.txt†L1124-L1132】

### Required Environment Variables

* **Supabase / Postgres** – `SUPABASE_URL`, `SUPABASE_SERVICE_KEY`, and (when using the upstream images) `SUPABASE_ANON_KEY` are required so Archon can read and write projects, tasks, knowledge, and embeddings. Populate these in `.env` before running `make up-archon` and share the same Supabase project you already use for PMOVES vectors.【F:docs/repoingest/coleam00-archon.txt†L523-L535】【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L872-L875】【F:docs/repoingest/coleam00-archon.txt†L53832-L53841】
* **MCP + callbacks** – Containers use `ARCHON_MCP_PORT`, `ARCHON_API_URL`, and `TRANSPORT` (defaults to HTTP SSE) to expose the MCP tool server. Downstream services such as Agent Zero map the MCP endpoint via `archon: mcp://http?endpoint=http://archon_mcp:${ARCHON_MCP_PORT}` inside their environment files.【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L839-L845】【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L872-L875】【F:docs/repoingest/coleam00-archon.txt†L53822-L53841】
* **NATS bridge** – The in-repo Archon FastAPI shim publishes envelopes to the event bus using `NATS_URL` and exposes `/events/publish` on its configured `PORT` (defaults to `8090`, overridden to `8091` in Compose). Ensure the NATS broker profile is running so Archon can announce events to the rest of PMOVES.【F:pmoves/services/archon/main.py†L6-L34】【F:pmoves/docker-compose.yml†L399-L409】
* **RAG/Geometry callbacks** – The Archon MCP implementation reads `HIRAG_URL`/`GATEWAY_URL`, `ARCHON_FORM`, and `AGENT_FORMS_DIR` to reach Hierarchical RAG endpoints and serve dynamic MCP forms to clients. Set these so geometry and knowledge commands forward correctly to the Hi-RAG gateway and shared form bundles.【F:pmoves/services/archon/mcp_server.py†L12-L33】【F:pmoves/services/archon/mcp_server.py†L60-L80】
* **LLMs and agents** – Point `OPENAI_API_KEY`, `OLLAMA_HOST`, and related keys at your preferred inference providers when running the upstream `archon_agents` container. Leave them unset if you only need the event bridge and MCP server.【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L848-L856】【F:docs/repoingest/coleam00-archon.txt†L523-L555】

### Build and Startup Flow

1. Copy `.env.example` → `.env`, fill in Supabase credentials, and (optionally) provider keys for embeddings and agents.【F:docs/repoingest/coleam00-archon.txt†L523-L555】【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L784-L801】
2. Apply the upstream migration bundle (`migration/complete_setup.sql`) in your Supabase project so the `sources`, `documents`, `projects`, `tasks`, and `code_examples` tables exist before Archon boots.【F:docs/repoingest/coleam00-archon.txt†L523-L535】【F:docs/repoingest/coleam00-archon.txt†L1238-L1246】
3. Start the baseline PMOVES data plane with `make up`, then bring the Archon profile online via `make up-archon` (or run the upstream `docker compose up --build -d` if you prefer the full Archon repository).【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L784-L801】【F:docs/repoingest/coleam00-archon.txt†L536-L555】
4. Confirm the MCP server responds on `http://localhost:8051` and that Socket.IO updates stream from the API on port `8181`/`8050`, then wire Agent Zero or other MCP clients to the published endpoint via the compose network mapping.【F:docs/repoingest/coleam00-archon.txt†L1124-L1132】【F:docs/repoingest/coleam00-archon.txt†L1172-L1193】【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L839-L845】

### Supabase Schema Expectations

Archon persists knowledge and project data in Supabase. At minimum it expects the following tables, created by the upstream migration scripts:

* `sources` – crawled websites and raw uploads
* `documents` – processed document chunks plus embeddings
* `projects` – optional project management records
* `tasks` – kanban task data tied to projects
* `code_examples` – extracted code snippets for reuse

Run `migration/complete_setup.sql` from the Archon repository (and related reset scripts when needed) to bootstrap or refresh these tables before connecting PMOVES services.【F:docs/repoingest/coleam00-archon.txt†L523-L535】【F:docs/repoingest/coleam00-archon.txt†L1238-L1246】

### MCP and Realtime Interfaces

The Archon API exposes MCP tooling over HTTP: `GET /api/mcp/tools` to enumerate commands, `POST /api/mcp/tools/{tool_name}` to invoke them, and `GET /api/mcp/health` for status checks. Project and task APIs live under `/api/projects` when the feature is enabled. Real-time feedback (crawl progress, project creation, task updates, knowledge refresh) streams to the UI and other subscribers over Socket.IO from the main server port.【F:docs/repoingest/coleam00-archon.txt†L1172-L1201】

Inside PMOVES, other agents connect through the compose overlay network using the HTTP MCP endpoint advertised in `agent-zero.env`, while the Archon bridge service forwards geometry and Hi-RAG callbacks to `HIRAG_URL` and emits envelopes to the shared NATS bus so downstream automation (n8n, mesh agents, Discord publishers) receive Archon events immediately.【F:pmoves/docs/PMOVES.ffmpeg/pmoves_orchestration_mesh_repo_scaffold.md†L872-L875】【F:pmoves/services/archon/mcp_server.py†L12-L80】【F:pmoves/services/archon/main.py†L6-L34】
