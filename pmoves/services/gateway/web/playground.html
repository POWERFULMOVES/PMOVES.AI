<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PMOVES · Mix & Match Playground</title>
  <style>
    body{font-family:ui-sans-serif,system-ui;background:#0b1020;color:#e5e7eb;margin:2rem}
    h1{margin:0 0 .6rem}
    .grid{display:grid;grid-template-columns:1.1fr 1.1fr 1fr;gap:16px}
    .panel{border:1px solid #1f2a44;border-radius:10px;padding:14px;background:#0b102008}
    textarea{width:100%;min-height:180px;background:#0b162b;color:#e5e7eb;border:1px solid #223457;border-radius:8px;padding:8px}
    input[type="number"],input[type="text"]{background:#0b162b;color:#e5e7eb;border:1px solid #223457;border-radius:6px;padding:6px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .sl{width:160px}
    button{padding:.5rem .8rem;border:1px solid #2a3b62;background:#0e1830;color:#e5e7eb;border-radius:8px;cursor:pointer}
    pre{background:#0b162b;color:#b7fbce;border:1px solid #223457;border-radius:8px;padding:10px;min-height:120px}
    a{color:#22d3ee;text-decoration:none}
    @media(max-width:1100px){ .grid{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <h1>Mix & Match · CHIT Constellations</h1>
  <p style="color:#94a3b8">Blend anchors and spectra from two constellations, visualize the shape, and preview decoded text using the server's geometry-only decoder. If <code>CHIT_LEARNED_TEXT=true</code>, responses also include a learned summary.</p>

  <div class="row" style="margin-bottom:10px">
    <button id="load-recent">Load recent shape</button>
    <label>or pick: <select id="shapePick"></select></label>
    <label style="margin-left:12px">A: <select id="pickA"></select></label>
    <label>B: <select id="pickB"></select></label>
    <span id="recent-info" style="color:#94a3b8"></span>
  </div>

  <div class="grid">
    <div class="panel">
      <h3>A · Constellation JSON</h3>
      <textarea id="taA" placeholder='{"id":"const_A", "anchor":[...], "radial_minmax":[-1,1], "spectrum":[...], "points":[]}'></textarea>
    </div>
    <div class="panel">
      <h3>B · Constellation JSON</h3>
      <textarea id="taB" placeholder='{"id":"const_B", "anchor":[...], "radial_minmax":[-1,1], "spectrum":[...], "points":[]}'></textarea>
    </div>
    <div class="panel">
      <h3>Controls</h3>
      <div class="row">
        <label>Anchor mix α</label><input class="sl" id="aAlpha" type="range" min="0" max="1" step="0.01" value="0.5"><span id="aAlphaV">0.50</span>
      </div>
      <div class="row">
        <label>Spectrum mix β</label><input class="sl" id="sAlpha" type="range" min="0" max="1" step="0.01" value="0.5"><span id="sAlphaV">0.50</span>
      </div>
      <div class="row">
        <label>dim_x</label><input id="dimx" type="number" value="0" min="0" style="width:70px">
        <label>dim_y</label><input id="dimy" type="number" value="1" min="0" style="width:70px">
        <label>rotate°</label><input id="rot" type="number" value="0" step="1" style="width:80px">
        <label>preset</label>
        <select id="preset">
          <option value="0,1">0 / 1</option>
          <option value="1,2">1 / 2</option>
          <option value="2,3">2 / 3</option>
          <option value="0,2">0 / 2</option>
          <option value="0,3">0 / 3</option>
        </select>
      </div>
      <div class="row">
        <label><input type="checkbox" id="mixAnchor" checked> Mix anchor</label>
        <label><input type="checkbox" id="mixSpectrum" checked> Mix spectrum</label>
        <label><input type="checkbox" id="lockR" > Lock rmin/rmax to A</label>
      </div>
      <div class="row">
        <label>Codebook</label>
        <input id="codebook" type="text" placeholder="tests/data/codebook.jsonl" style="width:260px">
      </div>
      <div class="row" style="margin-top:8px">
        <button id="vizA">Render A</button>
        <button id="vizB">Render B</button>
        <button id="vizMix">Render Mix</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="decodeA">Decode A</button>
        <button id="decodeB">Decode B</button>
        <button id="decodeMix">Mix & Decode</button>
        <button id="calA">Calibrate A</button>
        <button id="calB">Calibrate B</button>
        <button id="calMix">Calibrate Mix</button>
      </div>
    </div>
  </div>

  <div class="grid" style="margin-top:16px">
    <div class="panel">
      <h3>Visualization</h3>
      <img id="img" style="max-width:100%;display:block;border:1px solid #223457;border-radius:8px"/>
    </div>
    <div class="panel" style="grid-column: span 2">
      <h3>Decoded Text</h3>
      <pre id="out">(no results yet)</pre>
    </div>
  </div>

  <script>
    const $ = s => document.querySelector(s);
    const j = t => JSON.parse(t);
    const shapeURL = (path) => path;

    const updateLabels = () => {
      $("#aAlphaV").textContent = (+$("#aAlpha").value).toFixed(2);
      $("#sAlphaV").textContent = (+$("#sAlpha").value).toFixed(2);
    };
    $("#aAlpha").oninput = updateLabels;
    $("#sAlpha").oninput = updateLabels;
    updateLabels();

    function qb(){ const p = {}; const cb=$("#codebook").value.trim(); if(cb) p.codebook_path = cb; return new URLSearchParams(p); }
    async function renderConst(constObj){
      const q = new URLSearchParams({dim_x: $("#dimx").value, dim_y: $("#dimy").value, rotate: $("#rot").value});
      const r = await fetch(`/viz/constellation.svg?${q}`, {method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(constObj)});
      const blob = await r.blob();
      $("#img").src = URL.createObjectURL(blob);
    }

    async function decodeConst(constObj){
      const r = await fetch('/viz/preview/decode?'+qb(), {method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(constObj)});
      const obj = await r.json();
      $("#out").textContent = JSON.stringify(obj, null, 2);
    }

    async function mixAndDecode(a,b){
      const payload = { const_a: a, const_b: b, alpha_anchor: +$("#aAlpha").value, alpha_spectrum: +$("#sAlpha").value };
      const r = await fetch('/viz/mix/decode?'+qb(), {method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(payload)});
      const obj = await r.json();
      $("#out").textContent = JSON.stringify(obj, null, 2);
      // also render the mixed viz by asking server to render the mixed constellation directly
      // we reconstruct the mixed constellation client-side similarly for visualization
      try{
        const mxA = $("#mixAnchor").checked, mxS = $("#mixSpectrum").checked, lockR = $("#lockR").checked;
        const anchor = normalize(mxA ? mixArray(a.anchor||[], b.anchor||[], +$("#aAlpha").value) : (a.anchor||[]));
        const spectrum = normalize(mxS ? mixArray(a.spectrum||[], b.spectrum||[], +$("#sAlpha").value) : (a.spectrum||[]));
        const rmin = lockR ? (a.radial_minmax?.[0]||0) : ( (1-+$("#aAlpha").value)*(a.radial_minmax?.[0]||0) + (+$("#aAlpha").value)*(b.radial_minmax?.[0]||0) );
        const rmax = lockR ? (a.radial_minmax?.[1]||1) : ( (1-+$("#aAlpha").value)*(a.radial_minmax?.[1]||1) + (+$("#aAlpha").value)*(b.radial_minmax?.[1]||1) );
        const mixed = { id:`mix:${a.id}|${b.id}`, anchor: normalize(anchor), radial_minmax:[rmin,rmax], spectrum, points:[] };
        await renderConst(mixed);
      }catch(e){}
    }

    function mixArray(a,b,alpha){
      const n = Math.max(a.length,b.length); const out=[];
      for(let i=0;i<n;i++){ const va=+((i<a.length)?a[i]:0), vb=+((i<b.length)?b[i]:0); out.push((1-alpha)*va + alpha*vb); }
      return out;
    }
    function normalize(arr){ const s = arr.reduce((acc,x)=>acc+Math.max(0,+x),0)||1; return arr.map(x=>Math.max(0,+x)/s); }

    $("#vizA").onclick = ()=> { try{ renderConst(j($("#taA").value)); }catch(e){ alert("Invalid JSON A") } };
    $("#vizB").onclick = ()=> { try{ renderConst(j($("#taB").value)); }catch(e){ alert("Invalid JSON B") } };
    $("#vizMix").onclick = ()=> { try{ const a=j($("#taA").value), b=j($("#taB").value); const mxA=$("#mixAnchor").checked, mxS=$("#mixSpectrum").checked, lockR=$("#lockR").checked; const mixA= +$("#aAlpha").value, mixS= +$("#sAlpha").value; const anchor = normalize(mxA?mixArray(a.anchor||[], b.anchor||[], mixA):(a.anchor||[])); const spectrum = normalize(mxS?mixArray(a.spectrum||[], b.spectrum||[], mixS):(a.spectrum||[])); const rmin= lockR ? (a.radial_minmax?.[0]||0) : ((1-mixA)*(a.radial_minmax?.[0]||0)+mixA*(b.radial_minmax?.[0]||0)); const rmax= lockR ? (a.radial_minmax?.[1]||1) : ((1-mixA)*(a.radial_minmax?.[1]||1)+mixA*(b.radial_minmax?.[1]||1)); renderConst({id:`mix:${a.id}|${b.id}`, anchor, radial_minmax:[rmin,rmax], spectrum, points:[]}); }catch(e){ alert("Invalid JSON for mix") } };
    $("#decodeA").onclick = ()=> { try{ decodeConst(j($("#taA").value)); }catch(e){ alert("Invalid JSON A") } };
    $("#decodeB").onclick = ()=> { try{ decodeConst(j($("#taB").value)); }catch(e){ alert("Invalid JSON B") } };
    $("#decodeMix").onclick = ()=> { try{ mixAndDecode(j($("#taA").value), j($("#taB").value)); }catch(e){ alert("Invalid JSON") } };

    $("#calA").onclick = async ()=>{ try{ const constObj=j($("#taA").value); const r = await fetch('/viz/preview/calibration?'+qb(), {method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(constObj)}); const obj = await r.json(); $("#out").textContent = JSON.stringify(obj, null, 2);}catch(e){ alert('Invalid JSON A') } };
    $("#calB").onclick = async ()=>{ try{ const constObj=j($("#taB").value); const r = await fetch('/viz/preview/calibration?'+qb(), {method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(constObj)}); const obj = await r.json(); $("#out").textContent = JSON.stringify(obj, null, 2);}catch(e){ alert('Invalid JSON B') } };
    $("#calMix").onclick = async ()=>{ try{ const a=j($("#taA").value), b=j($("#taB").value); const payload={ const_a:a, const_b:b, alpha_anchor:+$("#aAlpha").value, alpha_spectrum:+$("#sAlpha").value }; const r = await fetch('/viz/mix/calibration?'+qb(), {method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(payload)}); const obj = await r.json(); $("#out").textContent = JSON.stringify(obj, null, 2);}catch(e){ alert('Invalid JSON') } };

    async function refreshPicks(shapeId){
      const meta = await fetch(`/viz/shape/${shapeId}/constellations`).then(r=>r.json());
      const opts = meta.constellations.map((c,i)=>`<option value="${c.super_idx},${c.const_idx}">${c.id} [${c.super_idx}/${c.const_idx}]</option>`).join('');
      $("#pickA").innerHTML = opts; $("#pickB").innerHTML = opts;
      if(meta.constellations[0]){ const c0 = meta.constellations[0]; const obj = await fetch(`/data/${shapeId}.json`).then(r=>r.json()); const s = obj.super_nodes[c0.super_idx].constellations[c0.const_idx]; $("#taA").value = JSON.stringify(s, null, 2); }
      if(meta.constellations[1]){ const c1 = meta.constellations[1]; const obj = await fetch(`/data/${shapeId}.json`).then(r=>r.json()); const s1 = obj.super_nodes[c1.super_idx].constellations[c1.const_idx]; $("#taB").value = JSON.stringify(s1, null, 2); }
    }

    $("#load-recent").onclick = async ()=>{
      const ids = await fetch('/viz/recent').then(r=>r.json()).catch(()=>[]);
      if(!ids.length){ alert('No recent shapes found. Publish one first.'); return; }
      const shapeId = ids[0]; $("#recent-info").textContent = `Loaded: ${shapeId}`;
      $("#shapePick").value = shapeId;
      await refreshPicks(shapeId);
    };

    // Populate shape picker on load
    (async()=>{
      const ids = await fetch('/viz/recent').then(r=>r.json()).catch(()=>[]);
      $("#shapePick").innerHTML = ids.map(id=>`<option value="${id}">${id}</option>`).join('');
    })();

    $("#shapePick").onchange = async (e)=>{ const shapeId = e.target.value; await refreshPicks(shapeId); };
    $("#pickA").onchange = async (e)=>{ const [si,ci] = e.target.value.split(',').map(Number); const shapeId=$("#shapePick").value; const obj = await fetch(`/data/${shapeId}.json`).then(r=>r.json()); const s = obj.super_nodes?.[si]?.constellations?.[ci]; if(s){ $("#taA").value = JSON.stringify(s, null, 2); } };
    $("#pickB").onchange = async (e)=>{ const [si,ci] = e.target.value.split(',').map(Number); const shapeId=$("#shapePick").value; const obj = await fetch(`/data/${shapeId}.json`).then(r=>r.json()); const s = obj.super_nodes?.[si]?.constellations?.[ci]; if(s){ $("#taB").value = JSON.stringify(s, null, 2); } };

    $("#preset").onchange = ()=>{ const [dx,dy] = $("#preset").value.split(','); $("#dimx").value = dx; $("#dimy").value = dy; };
  </script>
</body>
</html>
