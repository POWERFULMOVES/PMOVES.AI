diff --git a/pmoves-v5/supabase/sql/004_publisher_audit.sql b/pmoves-v5/supabase/sql/004_publisher_audit.sql
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/supabase/sql/004_publisher_audit.sql
@@ 0,0 1,10 @@
+-- 004_publisher_audit.sql
+create table if not exists publisher_audit (
+  id bigserial primary key,
+  studio_id bigint references studio_board(id) on delete cascade,
+  action text not null,         -- e.g., 'notify.discord', 'jellyfin.refresh', 'error'
+  payload jsonb,                -- details (webhook response, error, etc.)
+  created_at timestamptz default now()
+);
+
+create index if not exists idx_pub_audit_studio on publisher_audit(studio_id);

diff --git a/pmoves-v5/env.publisher.enrich.additions b/pmoves-v5/env.publisher.enrich.additions
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/env.publisher.enrich.additions
@@ 0,0 1,4 @@
+# Publisher enrichments
+PUBLISHER_NOTIFY_DISCORD_WEBHOOK=
+PUBLISHER_REFRESH_ON_PUBLISH=true
+PUBLISHER_EMBED_COVER=true

diff --git a/pmoves-v5/services/publisher/requirements.txt b/pmoves-v5/services/publisher/requirements.txt
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/services/publisher/requirements.txt
@@ 0,0 1,2 @@
+requests==2.32.3
+rapidfuzz==3.9.4

diff --git a/pmoves-v5/services/publisher/publisher.py b/pmoves-v5/services/publisher/publisher.py
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/services/publisher/publisher.py
@@ 0,0 1,178 @@
+
+import os, time, json, requests
+from typing import Dict, Any, List, Optional
+from rapidfuzz import fuzz
+from datetime import datetime, timezone
+
+SUPA = os.environ.get("SUPA_REST_URL","http://postgrest:3000")
+SCHEMA = os.environ.get("SUPA_SCHEMA","public")
+JELLYFIN_URL = os.environ.get("JELLYFIN_URL","http://jellyfin:8096").rstrip("/")
+JELLYFIN_API_KEY = os.environ.get("JELLYFIN_API_KEY","")
+JELLYFIN_USER_ID = os.environ.get("JELLYFIN_USER_ID","")
+NAMESPACE = os.environ.get("PUBLISHER_NAMESPACE","pmoves")
+LOOP = int(os.environ.get("PUBLISHER_LOOP_SEC","10"))
+
+# Enrichments
+DISCORD_WEBHOOK = os.environ.get("PUBLISHER_NOTIFY_DISCORD_WEBHOOK","")
+REFRESH_ON_PUBLISH = os.environ.get("PUBLISHER_REFRESH_ON_PUBLISH","true").lower()=="true"
+EMBED_COVER = os.environ.get("PUBLISHER_EMBED_COVER","true").lower()=="true"
+
+def supa_select(table, params=None):
+    r = requests.get(f"{SUPA}/{table}", params=params or {}, timeout=30)
+    r.raise_for_status(); return r.json()
+
+def supa_update(table, id, patch: dict):
+    r = requests.patch(f"{SUPA}/{table}?id=eq.{id}", headers={"content-type":"application/json"}, data=json.dumps(patch), timeout=30)
+    r.raise_for_status(); return r.json()
+
+def supa_insert(table, row: dict):
+    r = requests.post(f"{SUPA}/{table}", headers={"content-type":"application/json"}, data=json.dumps(row), timeout=30)
+    r.raise_for_status(); return r.json()
+
+def audit(studio_id:int, action:str, payload:dict):
+    try:
+        supa_insert("publisher_audit", {"studio_id": studio_id, "action": action, "payload": payload})
+    except Exception as e:
+        print("audit error", e)
+
+def jellyfin_headers():
+    h = {"Accept":"application/json"}
+    if JELLYFIN_API_KEY:
+        h["X-Emby-Authorization"] = f"MediaBrowser Client=PMOVES, Device=Publisher, DeviceId=pmoves-publisher, Version=1.0.0, Token={JELLYFIN_API_KEY}"
+        h["X-MediaBrowser-Token"] = JELLYFIN_API_KEY
+    return h
+
+def jellyfin_search(title: str) -> Optional[dict]:
+    qs = {
+        "searchTerm": title,
+        "IncludeItemTypes": "Movie,Music,MusicVideo,Audio,Video",
+        "Limit": 25
+    }
+    paths = []
+    if JELLYFIN_USER_ID:
+        paths.append(f"/Users/{JELLYFIN_USER_ID}/Items")
+    paths.append("/Items")
+    best = None; best_score = -1.0
+    for p in paths:
+        try:
+            r = requests.get(JELLYFIN_URL + p, params=qs, headers=jellyfin_headers(), timeout=20)
+            if not r.ok: continue
+            items = (r.json().get("Items") or r.json().get("items") or [])
+            for it in items:
+                name = it.get("Name") or it.get("name") or ""
+                score = fuzz.WRatio(title, name)/100.0
+                if score > best_score:
+                    best = it; best_score = score
+        except Exception:
+            continue
+    if best is None: 
+        return None
+    best["_pmoves_match_score"] = best_score
+    return best
+
+def jellyfin_item_image_url(item_id: str) -> str:
+    # Primary image; include token if available
+    if not item_id: return ""
+    url = f"{JELLYFIN_URL}/Items/{item_id}/Images/Primary"
+    params = "?fillHeight=512&fillWidth=512&quality=90"
+    if JELLYFIN_API_KEY:
+        params += f"&api_key={JELLYFIN_API_KEY}"
+    return url + params
+
+def jellyfin_refresh(item_id: Optional[str] = None) -> Optional[dict]:
+    try:
+        if item_id:
+            # Try item refresh (metadata)
+            r = requests.post(f"{JELLYFIN_URL}/Items/{item_id}/Refresh", headers=jellyfin_headers(), timeout=20)
+            if r.status_code in (200,204): return {"status":"ok","scope":"item"}
+        # Fallback to full library refresh
+        r = requests.post(f"{JELLYFIN_URL}/Library/Refresh", headers=jellyfin_headers(), timeout=20)
+        return {"status": "ok" if r.status_code in (200,204) else "unknown", "scope":"library", "code": r.status_code}
+    except Exception as e:
+        return {"status":"error","error":str(e)}
+
+def discord_embed(ev: dict, jelly: Optional[dict]) -> dict:
+    title = ev.get("title") or "(no title)"
+    desc = f"**Namespace:** {ev.get('namespace','pmoves')}\n**Source:** {ev.get('source_type','text')}\n**URL:** {ev.get('content_url','')}"
+    embed = {
+        "title": f"Published: {title}",
+        "description": desc,
+        "timestamp": ev.get("published_at"),
+        "color": 0x5865F2  # blurple
+    }
+    if jelly and EMBED_COVER:
+        img_url = jellyfin_item_image_url(jelly.get("Id") or jelly.get("id",""))
+        if img_url:
+            embed["image"] = {"url": img_url}
+        fields = []
+        fields.append({"name":"Jellyfin Type","value": jelly.get("Type","?"), "inline": True})
+        fields.append({"name":"Match","value": f"{(jelly.get('_pmoves_match_score') or 0)*100:.1f}%", "inline": True})
+        embed["fields"] = fields
+    return {"embeds": [embed]}
+
+def build_event(studio_row: dict, jelly: Optional[dict], extractions: Optional[dict]) -> dict:
+    ev = {
+        "event": "content.published.v1",
+        "id": studio_row["id"],
+        "title": studio_row.get("title"),
+        "namespace": studio_row.get("namespace") or NAMESPACE,
+        "content_url": studio_row.get("content_url"),
+        "source_type": (extractions or {}).get("source_type","text"),
+        "extractions": extractions or {},
+        "published_at": datetime.now(timezone.utc).isoformat()
+    }
+    if jelly:
+        ev["jellyfin"] = {
+            "match_score": jelly.get("_pmoves_match_score"),
+            "item_id": jelly.get("Id") or jelly.get("id"),
+            "name": jelly.get("Name") or jelly.get("name"),
+            "type": jelly.get("Type") or jelly.get("type")
+        }
+    return ev
+
+def fetch_extractions(studio_id: int) -> Optional[dict]:
+    rows = supa_select("extractions", {"studio_id":"eq."+str(studio_id), "order":"created_at.desc", "limit":"1"})
+    if not rows: return None
+    return rows[0].get("payload") or {}
+
+def run_once():
+    rows = supa_select("studio_board", {"status":"eq.published", "order":"updated_at.asc", "limit":"10"})
+    for r in rows:
+        try:
+            jelly = jellyfin_search(r.get("title") or "")
+            extra = fetch_extractions(r["id"])
+            ev = build_event(r, jelly, extra)
+
+            # record event
+            supa_insert("published_events", {"studio_id": r["id"], "event": ev})
+            patch = {"published_event": ev}
+            if jelly and (jelly.get("Id") or jelly.get("id")):
+                patch["jellyfin_id"] = jelly.get("Id") or jelly.get("id")
+            supa_update("studio_board", r["id"], patch)
+
+            # Discord notification (rich embed)
+            if DISCORD_WEBHOOK:
+                try:
+                    payload = discord_embed(ev, jelly)
+                    dr = requests.post(DISCORD_WEBHOOK, json=payload, timeout=15)
+                    audit(r["id"], "notify.discord", {"status": dr.status_code, "ok": dr.ok})
+                except Exception as e:
+                    audit(r["id"], "error", {"kind":"discord", "error": str(e)})
+
+            # Jellyfin refresh (item or library)
+            if REFRESH_ON_PUBLISH:
+                res = jellyfin_refresh((jelly or {}).get("Id") or (jelly or {}).get("id"))
+                audit(r["id"], "jellyfin.refresh", res)
+
+            print("published enriched", r["id"])
+        except Exception as e:
+            audit(r.get("id",0), "error", {"kind":"publisher", "error": str(e)})
+            print("publisher error", r.get("id"), e)
+
+def main():
+    while True:
+        run_once()
+        time.sleep(LOOP)
+
+if __name__=="__main__":
+    main()

diff --git a/pmoves-v5/docs/PUBLISHER_ENRICHMENTS.md b/pmoves-v5/docs/PUBLISHER_ENRICHMENTS.md
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/docs/PUBLISHER_ENRICHMENTS.md
@@ 0,0 1,15 @@
+# Publisher Enrichments
+Adds three capabilities to the publisher worker:
+1) **Discord rich embeds** for published items (`PUBLISHER_NOTIFY_DISCORD_WEBHOOK`)
+2) **Jellyfin refresh** of the matched item (fallback to library refresh) on publish
+3) **Supabase audit log** (`publisher_audit` table) for notifications/refresh/errors
+
+## New SQL
+Run `supabase/sql/004_publisher_audit.sql` against your Supabase DB.
+
+## .env
+```
+PUBLISHER_NOTIFY_DISCORD_WEBHOOK=
+PUBLISHER_REFRESH_ON_PUBLISH=true
+PUBLISHER_EMBED_COVER=true
+```
