diff --git a/pmoves-v5/services/presign/requirements.txt b/pmoves-v5/services/presign/requirements.txt
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/services/presign/requirements.txt
@@ 0,0 1,5 @@
+fastapi==0.112.1
+uvicorn[standard]==0.30.6
+boto3==1.34.159
+python-multipart==0.0.9
+pydantic==2.8.2

diff --git a/pmoves-v5/services/presign/Dockerfile b/pmoves-v5/services/presign/Dockerfile
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/services/presign/Dockerfile
@@ 0,0 1,9 @@
+FROM python:3.11-slim
+WORKDIR /app
+ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
+RUN pip install --no-cache-dir --upgrade pip
+COPY requirements.txt ./
+RUN pip install --no-cache-dir -r requirements.txt
+COPY . .
+EXPOSE 8080
+CMD ["uvicorn","api:app","--host","0.0.0.0","--port","8080"]

diff --git a/pmoves-v5/services/presign/api.py b/pmoves-v5/services/presign/api.py
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/services/presign/api.py
@@ 0,0 1,97 @@
+
+import os, time, hmac, hashlib
+from typing import Optional, List, Dict
+from fastapi import FastAPI, HTTPException, Header, Query
+from pydantic import BaseModel, Field
+import boto3
+from botocore.config import Config
+
+def get_s3():
+    endpoint = os.environ.get("MINIO_ENDPOINT") or os.environ.get("S3_ENDPOINT")
+    access_key = os.environ.get("MINIO_ACCESS_KEY") or os.environ.get("AWS_ACCESS_KEY_ID")
+    secret_key = os.environ.get("MINIO_SECRET_KEY") or os.environ.get("AWS_SECRET_ACCESS_KEY")
+    region = os.environ.get("AWS_DEFAULT_REGION","us-east-1")
+    secure = (os.environ.get("MINIO_SECURE","true").lower() == "true")
+    if not (endpoint and access_key and secret_key):
+        raise RuntimeError("Missing MINIO/S3 credentials or endpoint")
+    # Build endpoint_url if not a full URL
+    if "://" not in endpoint:
+        endpoint_url = f"{'https' if secure else 'http'}://{endpoint}"
+    else:
+        endpoint_url = endpoint
+    return boto3.client("s3",
+        aws_access_key_id=access_key,
+        aws_secret_access_key=secret_key,
+        region_name=region,
+        endpoint_url=endpoint_url,
+        config=Config(s3={"addressing_style": "virtual"}))
+
+ALLOWED_BUCKETS = set([b.strip() for b in os.environ.get("ALLOWED_BUCKETS","").split(",") if b.strip()])
+SHARED_SECRET = os.environ.get("PRESIGN_SHARED_SECRET","")
+
+def check_auth(authorization: Optional[str] = Header(None)):
+    if not SHARED_SECRET:
+        return True
+    if not authorization or not authorization.lower().startswith("bearer "):
+        raise HTTPException(status_code=401, detail="missing bearer")
+    token = authorization.split(" ",1)[1].strip()
+    if not hmac.compare_digest(token, SHARED_SECRET):
+        raise HTTPException(status_code=403, detail="bad token")
+    return True
+
+def check_bucket(bucket: str):
+    if ALLOWED_BUCKETS and bucket not in ALLOWED_BUCKETS:
+        raise HTTPException(status_code=403, detail="bucket not allowed")
+
+class PresignReq(BaseModel):
+    bucket: str
+    key: str
+    expires: int = Field(default=900, ge=60, le=604800)  # 1 min to 7 days
+    content_type: Optional[str] = None
+
+class PresignPostReq(BaseModel):
+    bucket: str
+    key: str
+    expires: int = Field(default=900, ge=60, le=604800)
+    content_type: Optional[str] = None
+    acl: Optional[str] = None
+
+app = FastAPI(title="PMOVES Presign", version="1.0.0")
+
+@app.get("/healthz")
+def healthz():
+    return {"ok": True, "time": int(time.time())}
+
+@app.post("/presign/put")
+def presign_put(req: PresignReq, authorization: Optional[str] = Header(None)):
+    check_auth(authorization); check_bucket(req.bucket)
+    s3 = get_s3()
+    params = {"Bucket": req.bucket, "Key": req.key}
+    if req.content_type:
+        params["ContentType"] = req.content_type
+    url = s3.generate_presigned_url("put_object", Params=params, ExpiresIn=req.expires)
+    return {"url": url, "method": "PUT", "headers": {"Content-Type": req.content_type} if req.content_type else {}}
+
+@app.post("/presign/get")
+def presign_get(req: PresignReq, authorization: Optional[str] = Header(None)):
+    check_auth(authorization); check_bucket(req.bucket)
+    s3 = get_s3()
+    params = {"Bucket": req.bucket, "Key": req.key}
+    url = s3.generate_presigned_url("get_object", Params=params, ExpiresIn=req.expires)
+    return {"url": url, "method": "GET"}
+
+@app.post("/presign/post")
+def presign_post(req: PresignPostReq, authorization: Optional[str] = Header(None)):
+    check_auth(authorization); check_bucket(req.bucket)
+    s3 = get_s3()
+    fields = {}
+    conditions = []
+    if req.content_type:
+        fields["Content-Type"] = req.content_type
+        conditions.append({"Content-Type": req.content_type})
+    if req.acl:
+        fields["acl"] = req.acl
+        conditions.append({"acl": req.acl})
+    post = s3.generate_presigned_post(req.bucket, req.key, Fields=fields, Conditions=conditions, ExpiresIn=req.expires)
+    return {"url": post["url"], "fields": post["fields"]}
+

diff --git a/pmoves-v5/compose-presign-snippet.yml b/pmoves-v5/compose-presign-snippet.yml
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/compose-presign-snippet.yml
@@ 0,0 1,14 @@
+presign:
+  build: ./services/presign
+  restart: unless-stopped
+  env_file: [.env]
+  environment:
+    - MINIO_ENDPOINT=${MINIO_ENDPOINT}
+    - MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
+    - MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
+    - MINIO_SECURE=${MINIO_SECURE:-false}
+    - AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-east-1}
+    - ALLOWED_BUCKETS=${ALLOWED_BUCKETS:-assets,outputs}
+    - PRESIGN_SHARED_SECRET=${PRESIGN_SHARED_SECRET}
+  ports: ["8088:8080"]
+  profiles: ["data","orchestration"]

diff --git a/pmoves-v5/env.presign.additions b/pmoves-v5/env.presign.additions
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/env.presign.additions
@@ 0,0 1,8 @@
+# Presign microservice (MinIO/S3)
+MINIO_ENDPOINT=localhost:9000
+MINIO_ACCESS_KEY=minioadmin
+MINIO_SECRET_KEY=minioadmin
+MINIO_SECURE=false
+AWS_DEFAULT_REGION=us-east-1
+ALLOWED_BUCKETS=assets,outputs
+PRESIGN_SHARED_SECRET=change_me

diff --git a/pmoves-v5/comfyui/custom_nodes/pmoves_minio_nodes/pmoves_minio_nodes.py b/pmoves-v5/comfyui/custom_nodes/pmoves_minio_nodes/pmoves_minio_nodes.py
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/comfyui/custom_nodes/pmoves_minio_nodes/pmoves_minio_nodes.py
@@ 0,0 1,100 @@
+
+# PMOVES MinIO Presign Nodes for ComfyUI
+import os, io, json, requests, time, mimetypes
+from typing import Tuple, List
+from PIL import Image
+
+PRESIGN_URL = os.environ.get("PMOVES_PRESIGN_URL","http://localhost:8088")
+PRESIGN_TOKEN = os.environ.get("PMOVES_PRESIGN_TOKEN","")
+
+def _auth_headers():
+    return {"Authorization": f"Bearer {PRESIGN_TOKEN}"} if PRESIGN_TOKEN else {}
+
+class PMovesUploadImage:
+    """
+    Uploads an IMAGE to MinIO using presigned PUT.
+    """
+    @classmethod
+    def INPUT_TYPES(s):
+        return {
+            "required": {
+                "image": ("IMAGE",),
+                "bucket": ("STRING", {"default":"outputs"}),
+                "key_prefix": ("STRING", {"default":"comfy/"}),
+                "filename": ("STRING", {"default":"image.png"}),
+                "content_type": ("STRING", {"default":"image/png"}),
+                "expires": ("INT", {"default": 900, "min":60, "max":604800})
+            }
+        }
+    RETURN_TYPES = ("STRING","STRING")
+    RETURN_NAMES = ("s3_uri","presigned_get")
+    FUNCTION = "upload"
+    CATEGORY = "PMOVES/MinIO"
+
+    def upload(self, image, bucket, key_prefix, filename, content_type, expires):
+        # image is a batch; take first frame
+        i =  image[0].cpu().numpy()
+        # convert from ComfyUI tensor (0..1 RGB) to PIL
+        pil = Image.fromarray((i * 255).clip(0,255).astype("uint8"))
+        buf = io.BytesIO()
+        pil.save(buf, format="PNG" if content_type=="image/png" else "JPEG")
+        data = buf.getvalue()
+
+        key = key_prefix + filename
+        # Get PUT URL
+        rs = requests.post(f"{PRESIGN_URL}/presign/put", json={"bucket":bucket,"key":key,"expires":expires,"content_type":content_type}, headers=_auth_headers(), timeout=10)
+        rs.raise_for_status()
+        put = rs.json()
+        # Upload
+        up = requests.put(put["url"], data=data, headers={"Content-Type": content_type}) if content_type else None, timeout=30)
+        if up.status_code not in (200,204):
+            raise RuntimeError(f"upload failed: {up.status_code}")
+        # Get GET URL
+        gs = requests.post(f"{PRESIGN_URL}/presign/get", json={"bucket":bucket,"key":key,"expires":expires}, headers=_auth_headers(), timeout=10)
+        gs.raise_for_status()
+        get = gs.json()
+        return (f"s3://{bucket}/{key}", get["url"])
+
+class PMovesUploadFilePath:
+    """
+    Uploads a file from disk (path) via presigned PUT.
+    """
+    @classmethod
+    def INPUT_TYPES(s):
+        return {
+            "required": {
+                "file_path": ("STRING",),
+                "bucket": ("STRING", {"default":"outputs"}),
+                "key": ("STRING", {"default":"comfy/out.bin"}),
+                "expires": ("INT", {"default": 900, "min":60, "max":604800})
+            }
+        }
+    RETURN_TYPES = ("STRING","STRING")
+    RETURN_NAMES = ("s3_uri","presigned_get")
+    FUNCTION = "upload"
+    CATEGORY = "PMOVES/MinIO"
+
+    def upload(self, file_path, bucket, key, expires):
+        if not os.path.exists(file_path):
+            raise ValueError(f"file not found: {file_path}")
+        ctype = mimetypes.guess_type(file_path)[0] or "application/octet-stream"
+        with open(file_path,"rb") as f:
+            data = f.read()
+        rs = requests.post(f"{PRESIGN_URL}/presign/put", json={"bucket":bucket,"key":key,"expires":expires,"content_type":ctype}, headers=_auth_headers(), timeout=10)
+        rs.raise_for_status()
+        put = rs.json()
+        up = requests.put(put["url"], data=data, headers={"Content-Type": ctype}, timeout=60)
+        if up.status_code not in (200,204): raise RuntimeError(f"upload failed: {up.status_code}")
+        gs = requests.post(f"{PRESIGN_URL}/presign/get", json={"bucket":bucket,"key":key,"expires":expires}, headers=_auth_headers(), timeout=10)
+        gs.raise_for_status()
+        get = gs.json()
+        return (f"s3://{bucket}/{key}", get["url"])
+
+NODE_CLASS_MAPPINGS = {
+    "PMovesUploadImage": PMovesUploadImage,
+    "PMovesUploadFilePath": PMovesUploadFilePath,
+}
+NODE_DISPLAY_NAME_MAPPINGS = {
+    "PMovesUploadImage": "PMOVES • Upload Image (MinIO)",
+    "PMovesUploadFilePath": "PMOVES • Upload File Path (MinIO)",
+}

diff --git a/pmoves-v5/docs/COMFYUI_MINIO_PRESIGN.md b/pmoves-v5/docs/COMFYUI_MINIO_PRESIGN.md
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/pmoves-v5/docs/COMFYUI_MINIO_PRESIGN.md
@@ 0,0 1,69 @@
+# ComfyUI ↔ MinIO Presign Microservice
+
+A tiny FastAPI service that issues **presigned PUT/GET/POST** URLs for MinIO/S3, plus **ComfyUI custom nodes** to upload images/files directly to MinIO.
+
+## Service
+
+### .env
+```
+MINIO_ENDPOINT=localhost:9000
+MINIO_ACCESS_KEY=minioadmin
+MINIO_SECRET_KEY=minioadmin
+MINIO_SECURE=false
+AWS_DEFAULT_REGION=us-east-1
+ALLOWED_BUCKETS=assets,outputs
+PRESIGN_SHARED_SECRET=change_me
+```
+
+### Compose snippet
+Add under `services:`
+```yaml
+presign:
+  build: ./services/presign
+  restart: unless-stopped
+  env_file: [.env]
+  environment:
+    MINIO_ENDPOINT: ${MINIO_ENDPOINT}
+    MINIO_ACCESS_KEY: ${MINIO_ACCESS_KEY}
+    MINIO_SECRET_KEY: ${MINIO_SECRET_KEY}
+    MINIO_SECURE: ${MINIO_SECURE:-false}
+    AWS_DEFAULT_REGION: ${AWS_DEFAULT_REGION:-us-east-1}
+    ALLOWED_BUCKETS: ${ALLOWED_BUCKETS:-assets,outputs}
+    PRESIGN_SHARED_SECRET: ${PRESIGN_SHARED_SECRET}
+  ports: ["8088:8080"]
+  profiles: ["data","orchestration"]
+```
+
+### Endpoints
+- `POST /presign/put` — body: `{bucket,key,expires,content_type?}` → `{url, method:"PUT", headers}`  
+- `POST /presign/get` — body: `{bucket,key,expires}` → `{url, method:"GET"}`  
+- `POST /presign/post` — browser-friendly multipart form fields
+
+Send `Authorization: Bearer <PRESIGN_SHARED_SECRET>` if set.
+
+## ComfyUI Nodes
+
+Copy `comfyui/custom_nodes/pmoves_minio_nodes` into your ComfyUI `custom_nodes/` and restart ComfyUI.
+
+Env for nodes (optional):
+```
+PMOVES_PRESIGN_URL=http://localhost:8088
+PMOVES_PRESIGN_TOKEN=change_me
+```
+
+Nodes:
+- **PMOVES • Upload Image (MinIO)** — takes `IMAGE`, `bucket`, `key_prefix`, `filename`; returns `s3://…` and a temporary GET URL.
+- **PMOVES • Upload File Path (MinIO)** — uploads any on-disk file.
+
+## Quick Test
+```bash
+# PUT
+curl -s http://localhost:8088/presign/put -H "authorization: Bearer $PRESIGN_SHARED_SECRET"   -H 'content-type: application/json'   -d '{"bucket":"outputs","key":"comfy/hello.txt","expires":600,"content_type":"text/plain"}' | jq -r .url |   xargs -I{} curl -s -X PUT -H 'content-type: text/plain' --data 'hello pmoves' '{}'
+
+# GET
+curl -s http://localhost:8088/presign/get -H "authorization: Bearer $PRESIGN_SHARED_SECRET"   -H 'content-type: application/json'   -d '{"bucket":"outputs","key":"comfy/hello.txt","expires":600}' | jq -r .url | xargs -I{} curl -s '{}'
+```
+
+## Notes
+- Limit access by setting `ALLOWED_BUCKETS` and a strong `PRESIGN_SHARED_SECRET`.
+- For public Discord embeds, use a publicly reachable MinIO or a CDN in front (or host via presigned GET).
