"""Generate env files from the CHIT secrets manifest."""

from __future__ import annotations

import argparse
import sys
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Mapping, MutableMapping, Sequence

import yaml

from pmoves.chit.codec import decode_secret_map, load_cgp

PROJECT_ROOT = Path(__file__).resolve().parents[1]
REPO_ROOT = PROJECT_ROOT.parent


@dataclass
class Target:
    file: str
    key: str


@dataclass
class Entry:
    id: str
    label: str
    required: bool
    targets: Sequence[Target]


def load_manifest(path: Path) -> tuple[Path, Sequence[Entry]]:
    manifest_data = yaml.safe_load(path.read_text())
    if not isinstance(manifest_data, Mapping):
        raise ValueError("Manifest must be a mapping")
    if manifest_data.get("version") != 1:
        raise ValueError("Unsupported manifest version")

    default_targets: Sequence[Target] = []
    defaults = manifest_data.get("defaults", {})
    if isinstance(defaults, Mapping):
        target_data = defaults.get("targets", [])
        if isinstance(target_data, list):
            default_targets = [_parse_target(item) for item in target_data]

    cgp_file = manifest_data.get("cgp_file")
    if not isinstance(cgp_file, str):
        raise ValueError("Manifest missing 'cgp_file'")
    cgp_path = (REPO_ROOT / cgp_file).resolve()

    entries_raw = manifest_data.get("entries")
    if not isinstance(entries_raw, list):
        raise ValueError("Manifest 'entries' must be a list")

    entries: List[Entry] = []
    for item in entries_raw:
        if not isinstance(item, Mapping):
            continue
        entry_id = item.get("id")
        source = item.get("source", {})
        if not isinstance(entry_id, str):
            raise ValueError("Entry missing id")
        if not isinstance(source, Mapping):
            raise ValueError(f"Entry {entry_id} missing source mapping")
        if source.get("type") != "cgp":
            raise ValueError(f"Entry {entry_id} uses unsupported source")
        label = source.get("label")
        if not isinstance(label, str):
            raise ValueError(f"Entry {entry_id} missing source label")

        targets_data = item.get("targets")
        if isinstance(targets_data, list) and targets_data:
            targets = [_parse_target(t) for t in targets_data]
        else:
            targets = list(default_targets)
        if not targets:
            raise ValueError(f"Entry {entry_id} has no targets")

        required = bool(item.get("required", True))
        entries.append(Entry(id=entry_id, label=label, required=required, targets=targets))

    return cgp_path, entries


def _parse_target(data: Mapping) -> Target:
    if not isinstance(data, Mapping):
        raise ValueError("Target must be a mapping")
    file_name = data.get("file")
    key = data.get("key")
    if not isinstance(file_name, str) or not file_name:
        raise ValueError("Target missing file")
    if key is None:
        key = ""
    if not isinstance(key, str) or not key:
        raise ValueError("Target missing key")
    return Target(file=file_name, key=key)


def build_outputs(
    secrets: Mapping[str, str],
    entries: Sequence[Entry],
    *,
    strict: bool = True,
) -> tuple[Dict[str, Dict[str, str]], List[str]]:
    outputs: Dict[str, Dict[str, str]] = defaultdict(dict)
    missing: List[str] = []
    for entry in entries:
        if entry.label not in secrets:
            if entry.required:
                missing.append(entry.label)
            continue
        value = secrets[entry.label]
        for target in entry.targets:
            outputs[target.file][target.key] = value
    if missing and strict:
        joined = ", ".join(sorted(missing))
        raise KeyError(f"Missing required secrets: {joined}")
    return outputs, missing


def write_env_files(outputs: Mapping[str, Mapping[str, str]]) -> None:
    header = "# Auto-generated by pmoves.tools.secrets_sync. Do not edit.\n"
    for relative, values in outputs.items():
        env_path = PROJECT_ROOT / relative
        env_path.parent.mkdir(parents=True, exist_ok=True)
        lines = [header]
        for key in sorted(values):
            lines.append(f"{key}={values[key]}\n")
        env_path.write_text("".join(lines))


def report(outputs: Mapping[str, Mapping[str, str]]) -> str:
    rows = []
    for file_name, values in sorted(outputs.items()):
        rows.append(f"{file_name}: {len(values)} entries")
    return "\n".join(rows)


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Seed env files from CHIT secrets manifest.")
    parser.add_argument(
        "command",
        choices=("generate", "report"),
        help="generate env files or report planned outputs",
    )
    parser.add_argument(
        "--manifest",
        default="pmoves/chit/secrets_manifest.yaml",
        help="path to secrets manifest (default: pmoves/chit/secrets_manifest.yaml)",
    )
    args = parser.parse_args(argv)

    manifest_path = (REPO_ROOT / args.manifest).resolve()
    cgp_path, entries = load_manifest(manifest_path)
    secrets = decode_secret_map(load_cgp(cgp_path))
    outputs, missing = build_outputs(secrets, entries)
    if missing:
        joined = ", ".join(sorted(missing))
        raise KeyError(f"Missing required secrets: {joined}")

    if args.command == "report":
        print(report(outputs))
        return 0

    write_env_files(outputs)
    print(report(outputs))
    return 0


if __name__ == "__main__":
    sys.exit(main())
