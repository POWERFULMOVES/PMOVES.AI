// deno-lint-ignore-file no-window

import * as Config from "/src/js/config.js";
export const config = Config;

let w3rpc = null;
let w3mm = null;
let w3mmAccount = null;
let availableProviders = {};

// Local storage keys
const STORAGE_KEYS = {
  WALLET_PROVIDER: "lastWalletProvider",
  WALLET_ADDRESS: "lastWalletAddress",
};

// contract type mapping
const contracts = {
  token: {
    abi: Config.tokenContractMeta.output.abi,
    rpc: null,
    mm: null,
    address: Config.tokenContractAddress,
  },
  signatures: {
    abi: Config.signaturesContractMeta.output.abi,
    rpc: null,
    mm: null,
    address: Config.signaturesContractAddress,
  },
};

//run on init
initialize();

export async function waitForInit() {
  while (contracts.token.rpc == null)
    await new Promise((resolve) => setTimeout(resolve, 100));
}

async function detectWallets() {
  if (typeof window.ethereum === "undefined") return false;

  if (window.ethereum["isConnected"] && window.ethereum.isConnected())
    return true;

  // Get all providers from the providerMap
  if (window.ethereum.providerMap) {
    availableProviders = {};
    for (const [name, provider] of window.ethereum.providerMap) {
      availableProviders[name] = provider;
    }
  }
  return Object.keys(availableProviders).length > 0;
}

async function showWalletSelectionPopup() {
  return new Promise((resolve) => {
    const overlay = document.createElement("div");
    overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        `;

    const popup = document.createElement("div");
    popup.style.cssText = `
            padding: 20px;
            border-radius: 10px;
            max-width: 400px;
            width: 90%;
        `;
    popup.classList.add("bg-sec");

    const title = document.createElement("h3");
    title.textContent = "Select a Wallet";
    title.classList.add("txt-pri");
    title.style.marginBottom = "20px";

    popup.appendChild(title);

    Object.keys(availableProviders).forEach((providerName) => {
      const button = document.createElement("button");
      button.textContent = providerName;
      button.style.cssText = `
                display: block;
                width: 100%;
                padding: 10px;
                margin: 5px 0;
                border: 1px solid #ddd;
                border-radius: 5px;
                cursor: pointer;
            `;
      button.classList.add("bg-pri", "txt-sec");
      button.onclick = () => {
        const selectedProvider = availableProviders[providerName];
        // window.ethereum.selectedProvider = selectedProvider;
        document.body.removeChild(overlay);
        resolve([providerName, selectedProvider]);
      };
      popup.appendChild(button);
    });

    overlay.appendChild(popup);
    document.body.appendChild(overlay);
  });
}

export async function initializeMm(forceSelection = false) {
  const walletsAvailable = await detectWallets();

  if (!walletsAvailable) {
    console.error("No web3 wallets detected");
    return;
  }

  let selectedProvider;
  const lastProvider = localStorage.getItem(STORAGE_KEYS.WALLET_PROVIDER);

  if (Object.keys(availableProviders).length > 0) {
    // Try to use the last provider if available and not forcing selection
    if (
      !forceSelection &&
      lastProvider &&
      window.ethereum.providerMap?.get(lastProvider)
    ) {
      selectedProvider = window.ethereum.providerMap.get(lastProvider);
      availableProviders[lastProvider] = selectedProvider;
    } else if (Object.keys(availableProviders).length === 1) {
      // If only one wallet is available, use it directly
      const providerName = Object.keys(availableProviders)[0];
      selectedProvider = availableProviders[providerName];
      saveWalletInfo(providerName, window.ethereum.selectedAddress);
    } else {
      // If multiple wallets are available, show selection popup
      const [providerName, provider] = await showWalletSelectionPopup();
      selectedProvider = provider;
      if (providerName && provider) {
        saveWalletInfo(providerName, window.ethereum.selectedAddress);
      }
    }

    if (!selectedProvider) {
      console.error("No wallet selected");
      return;
    }

    if (window.ethereum.setProvider) {
      // Set the selected provider as the active provider
      window.ethereum.setProvider(selectedProvider);
    } else {
      // If setProvider is not available, try to use the provider directly
      window.ethereum = selectedProvider;
    }
  }

  try {
    // Initialize Web3 with the selected provider
    w3mm = new Web3(selectedProvider);

    await switchNetwork();
    // await addToken();
    await selectAccount();
    for (const [type, contract] of Object.entries(contracts)) {
      contract.mm = new w3mm.eth.Contract(contract.abi, contract.address);
    }
  } catch (e) {
    clearWalletInfo();
    throw e;
  }
}

export async function addToken() {
  if (!window.ethereum) return;

  try {
    const currentAccount = await window.ethereum.request({
      method: "eth_accounts",
    });
    if (!currentAccount[0]) return;

    // Try to add token - if it's already added, user won't see a prompt
    const result = await window.ethereum.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address: contracts.token.address,
          symbol: Config.tokenSymbol,
          decimals: Config.decimals,
          image: "https://agent-zero.ai/res/favicon_round.png",
        },
      },
    });

    if (result) {
      console.log("Token added to wallet");
    }
  } catch (error) {
    if (error.code === 4001) {
      console.log("User rejected token addition");
    } else {
      console.error("Failed to add token:", error);
    }
  }
}

export async function initialize() {
  await initializeRpc();
  try {
    await tryReconnectLastWallet();
  } catch (e) {
    clearWalletInfo();
    globalThis.location.reload;
  }
}

export async function connectWallet(forceSelection = true) {
  // if (!contracts.token.abi) {
  //   await initialize();
  // }
  await initializeMm(forceSelection);
  return isWalletConnected(); // Return true if wallet was successfully connected
}

// Add function to check if wallet is connected
export function isWalletConnected() {
  return !!w3mm && !!window.ethereum.selectedAddress;
}

async function selectAccount() {
  // try {
  // Request account access
  const accounts = await window.ethereum.request({
    method: "eth_requestAccounts",
  });
  w3mmAccount = accounts[0];
  // } catch (error) {
  // console.error("User denied account access:" + error.toString());
  //   return;
  // }
}

export async function switchNetwork() {
  try {
    const targetChainId = Config.chainIdHex;
    // Check if the provider supports network switching
    const provider = window.ethereum;
    // const methods = await provider.request({
    //   method: "eth_requestAccounts",
    // });

    try {
      // First try to switch to the network
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: targetChainId }],
      });
      return true;
    } catch (switchError) {
      // Check if the error is because the chain hasn't been added
      if (
        switchError.code === 4902 ||
        switchError.message.includes("wallet_switchEthereumChain") ||
        switchError.message.toLowerCase().includes("unrecognized chain id")
      ) {
        try {
          // Add the network if it doesn't exist
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: targetChainId,
                rpcUrls: [Config.rpcUrl],
                chainName: Config.chainName || "Custom Network",
                nativeCurrency: Config.nativeCurrency || {
                  name: "ETH",
                  symbol: "ETH",
                  decimals: Config.decimals,
                },
                blockExplorerUrls: Config.blockExplorerUrls || [],
              },
            ],
          });
          return true;
        } catch (addError) {
          console.warn("Failed to add the network:", addError);
          return false;
        }
      } else {
        console.warn("Failed to switch network:", switchError);
        return false;
      }
    }
  } catch (error) {
    console.warn("Network switch/add failed:", error);
    return false;
  }
}

export async function validateNetwork() {
  // Use globalThis instead of window to avoid Deno lint warnings
  const currentChainId = await globalThis.ethereum.request({
    method: "eth_chainId",
  });
  if (currentChainId !== Config.chainIdHex) {
    throw new Error(
      "Please switch your wallet to the correct network - " + Config.chainName
    );
  }
  return currentChainId;
}

async function initializeRpc() {
  w3rpc = new Web3(Config.rpcUrl);
  for (const [type, contract] of Object.entries(contracts)) {
    contract.rpc = new w3rpc.eth.Contract(contract.abi, contract.address);
  }
}

export async function callPayableFunction(
  contractType,
  functionName,
  params = [],
  value = 0
) {
  if (!contracts[contractType]) {
    throw new Error(`Unknown contract type: ${contractType}`);
  }

  const contract = contracts[contractType].mm;
  if (!contract) await connectWallet();
  if (!contract) throw new Error("Contract is not initialized");

  await selectAccount();

  await validateNetwork();

  value = toBigInt(value);

  // Value should be in wei
  const transactionParameters = {
    to: contracts[contractType].address,
    from: w3mmAccount,
    value: w3mm.utils.toHex(value), // Convert Ether to wei
    data: contract.methods[functionName](...params).encodeABI(),
  };

  try {
    const txHash = await ethereum.request({
      method: "eth_sendTransaction",
      params: [transactionParameters],
    });
    console.log("Transaction hash:", txHash);
    return txHash;
  } catch (error) {
    console.error("Transaction failed:", error);
    throw error;
  }
}

export async function createAllowance(allowedContract, amount) {
  // call the token contract's "approve" function using callPayableFunction
  // convert the amount to BigInt if necessary
  // returns the transaction hash
  const txHash = await callPayableFunction(
    "token",
    "approve",
    [allowedContract, toBigInt(amount)],
    0
  );
  return txHash;
}

// signature eg. TokenPurchased(address,uint256)
export async function searchLogs(
  contractAddress,
  eventSignature,
  fromBlock,
  toBlock,
  topic2 = null,
  topic3 = null,
  topic4 = null
) {
  // If eventSignature is not already a hashed hex string, hash it.
  if (!eventSignature.startsWith("0x")) {
    eventSignature = Web3.utils.sha3(eventSignature);
  }

  // Build the topics array starting with the event signature hash.
  const topics = [eventSignature];
  if (topic2 !== null) topics.push(topic2);
  if (topic3 !== null) topics.push(topic3);
  if (topic4 !== null) topics.push(topic4);

  // Set up the filter for getPastLogs.
  const filter = {
    address: contractAddress,
    fromBlock: fromBlock,
    toBlock: toBlock,
    topics: topics,
  };

  try {
    const logs = await w3rpc.eth.getPastLogs(filter);
    console.log("Fetched Logs:", logs);
    return logs;
  } catch (error) {
    console.error("Error fetching logs:", error);
    throw error;
  }
}

export async function getBasePrice() {
  try {
    await waitForInit();
    const result = await contracts.token.rpc.methods
      .BASE_PRICE(/* arguments here */)
      .call();
    return result;
  } catch (error) {
    console.error("Error calling getBasePrice:", error);
    throw error;
  }
}

export async function getPriceIncreaseRate() {
  try {
    await waitForInit();
    const result = await contracts.token.rpc.methods
      .PRICE_INCREASE_RATE(/* arguments here */)
      .call();
    return result;
  } catch (error) {
    console.error("Error calling getPriceIncreaseRate:", error);
    throw error;
  }
}

export async function getCurrentPrice() {
  try {
    await waitForInit();
    const result = await contracts.token.rpc.methods
      .currentPrice(/* arguments here */)
      .call();
    return result;
  } catch (error) {
    console.error("Error calling getCurrentPrice:", error);
    throw error;
  }
}

export async function getTotalSupply() {
  try {
    await waitForInit();
    const result = await contracts.token.rpc.methods
      .totalSupply(/* arguments here */)
      .call();
    return result;
  } catch (error) {
    console.error("Error calling getCurrentPrice:", error);
    throw error;
  }
}

export async function getEthBalanceOf(addr) {
  try {
    if (!addr.startsWith("0x")) addr = "0x" + addr;
    await waitForInit();
    const result = await w3rpc.eth.getBalance(addr);
    return result;
  } catch (error) {
    console.error("Error calling getEthBalance for address:", addr, error);
    throw error;
  }
}

export async function getA0TBalanceOf(addr) {
  try {
    if (!addr.startsWith("0x")) addr = "0x" + addr;
    await waitForInit();
    const result = await contracts.token.rpc.methods.balanceOf(addr).call();
    return result;
  } catch (error) {
    console.error("Error calling getBalanceOf:", error);
    throw error;
  }
}

export async function getSignature(identifier) {
  try {
    await waitForInit();
    const identifierBytes32 = encode7Bit(identifier);
    const result = await contracts.signatures.rpc.methods
      .signatures(identifierBytes32)
      .call();

    // Convert the array result to a structured object
    return {
      identifier: decode7Bit(result.identifier),
      data: decode7Bit(result.data),
      signer: result.signer,
      timestamp: parseInt(result.timestamp),
      stake: fromBigInt(result.stake),
      stakeLock: parseInt(result.stakeLock),
    };
  } catch (error) {
    console.error("Error getting signature:", error);
    throw error;
  }
}

export async function checkSignatureExists(identifier) {
  try {
    await waitForInit();
    const signature = await getSignature(identifier);
    // If the signature exists, its timestamp will be non-zero
    return signature.timestamp > 0;
  } catch (error) {
    console.error("Error checking signature existence:", error);
    return false;
  }
}

export async function sendSignatures(signatures) {
  try {
    // //first ask for allowance if needed
    // let totalStake = 0n;
    // for (const sig of signatures) totalStake += toBigInt(sig.stake || 0) || 0n;
    // if (totalStake > 0n)
    //   await createAllowance(Config.signaturesContractAddress, totalStake);

    // Convert signature data to contract format
    const signatureData = signatures.map((sig) => ({
      identifier: encode7Bit(sig.identifier),
      data: sig.data,
      signer: "0x0000000000000000000000000000000000000000", // Will be set by contract
      timestamp: 0, // Will be set by contract
      stake: toBigInt(sig.stake),
      stakeLock: BigInt(sig.stakeLock),
    }));

    // Call contract method
    return await callPayableFunction("signatures", "sign", [signatureData]);
  } catch (error) {
    console.error("Error sending signatures:", error);
    throw error;
  }
}

export async function unstakeSignatures(identifiers) {
  try {
    // Convert string identifiers to bytes32
    const identifiersBytes32 = identifiers.map((id) => encode7Bit(id));

    // Call contract method
    return await callPayableFunction("signatures", "unstake", [
      identifiersBytes32,
    ]);
  } catch (error) {
    console.error("Error unstaking signatures:", error);
    throw error;
  }
}

export function toBigInt(num) {
  return typeof num === "bigint"
    ? num
    : BigInt(Math.round(Number(num) * 10 ** Config.decimals));
}

export function fromBigInt(num) {
  return typeof num === "bigint"
    ? Number(num) / 10 ** Config.decimals
    : Number(num);
}

export function encode7Bit(input) {
  let binaryString = "";

  // Convert each character to a 7-bit binary string
  for (const char of input) {
    const binaryChar = char.charCodeAt(0).toString(2).padStart(7, "0");
    binaryString += binaryChar;
  }

  // Pad the binary string to a multiple of 8 with zeros
  while (binaryString.length % 8 !== 0) {
    binaryString += "0";
  }

  // Convert the binary string to hexadecimal
  let hexResult = "";
  for (let i = 0; i < binaryString.length; i += 8) {
    const byte = binaryString.substring(i, i + 8);
    hexResult += parseInt(byte, 2).toString(16).padStart(2, "0");
  }

  // Pad the hex result to 64 characters
  hexResult = hexResult.padEnd(64, "0");

  return "0x" + hexResult;
}

export function decode7Bit(encoded) {
  // Remove '0x' prefix if present
  const cleanEncoded = encoded.replace(/^0x/, "").substring(0, 64);
  let binaryString = "";

  // Convert each hexadecimal pair to an 8-bit binary string
  for (let i = 0; i < cleanEncoded.length; i += 2) {
    const hexByte = cleanEncoded.substring(i, i + 2);
    binaryString += parseInt(hexByte, 16).toString(2).padStart(8, "0");
  }

  let result = "";
  for (let i = 0; i < binaryString.length; i += 7) {
    const binaryChar = binaryString.substring(i, i + 7);

    // Check for padding zeros and break if found
    if (i > binaryString.length - 8 || /^0+$/.test(binaryChar)) {
      break;
    }

    const charCode = parseInt(binaryChar, 2);
    result += String.fromCharCode(charCode);
  }

  return result;
}

export function toggle7Bit(event) {
  event.preventDefault();
  const inputField = event.target.querySelector('input[type="text"]');

  if (inputField.value.startsWith("0x")) {
    inputField.value = decode7Bit(inputField.value);
  } else {
    inputField.value = encode7Bit(inputField.value);
  }
}

export function getCurrentAddress(trim) {
  let addr = window.ethereum.selectedAddress;
  if (!addr) return null;
  addr = Web3.utils.toChecksumAddress(addr);
  const result = trim ? `${addr.slice(2, 7)}...${addr.slice(-5)}` : addr;
  return result;
}

// Save wallet info to localStorage
function saveWalletInfo(provider, address) {
  localStorage.setItem(STORAGE_KEYS.WALLET_PROVIDER, provider);
  localStorage.setItem(STORAGE_KEYS.WALLET_ADDRESS, address);
}

// Clear wallet info from localStorage
function clearWalletInfo() {
  localStorage.removeItem(STORAGE_KEYS.WALLET_PROVIDER);
  localStorage.removeItem(STORAGE_KEYS.WALLET_ADDRESS);
}

// Try to reconnect to the last used wallet
async function tryReconnectLastWallet() {
  const lastProvider = localStorage.getItem(STORAGE_KEYS.WALLET_PROVIDER);

  if (lastProvider && window.ethereum) {
    try {
      if (window.ethereum.providerMap) {
        const provider = window.ethereum.providerMap.get(lastProvider);
        if (provider) {
          availableProviders[lastProvider] = provider;
          await connectWallet(false); // Pass false to skip wallet selection
        }
      }
    } catch (error) {
      console.warn("Failed to reconnect to last wallet:", error);
      clearWalletInfo();
      throw error;
    }
  }
}

// Disconnect wallet
export function disconnect() {
  w3mm = null;
  w3mmAccount = null;
  clearWalletInfo();
  // You might want to trigger a UI update here
}

/**
 * Propose a token transfer transaction
 * @param {number} amount - Amount of tokens to transfer
 * @param {string} toAddress - Recipient wallet address
 * @returns {Promise<string>} Transaction hash
 */
export async function proposeTokenTransfer(amount, toAddress) {
  const contract = contracts.token.mm;
  if (!contract) await connectWallet();
  if (!contract) throw new Error("Contract is not initialized");

  await selectAccount();

  await validateNetwork();

  // Convert amount to BigInt (wei equivalent for token)
  const amountWei = toBigInt(amount);

  // Encode the transfer function call
  const transferData = contract.methods.transfer(toAddress, amountWei).encodeABI();

  // Prepare transaction parameters
  const transactionParameters = {
    to: contracts.token.address,
    from: w3mmAccount,
    value: '0x0', // No ETH value for token transfer
    data: transferData,
  };

  try {
    // Send transaction request to MetaMask
    const txHash = await window.ethereum.request({
      method: 'eth_sendTransaction',
      params: [transactionParameters],
    });
    
    console.log('Token transfer transaction hash:', txHash);
    return txHash;
  } catch (error) {
    console.error('Token transfer transaction failed:', error);
    throw error;
  }
}
