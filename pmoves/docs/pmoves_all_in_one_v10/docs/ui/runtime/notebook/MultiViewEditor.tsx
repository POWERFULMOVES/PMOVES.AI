import React, { useState } from "react";
import type { MessageView } from "./useSupabaseViews";
import { SelectionCanvas } from "./SelectionCanvas";
import { CanvasToolbar } from "./CanvasToolbar";
import { BaselineOverlay } from "./BaselineOverlay";
type Layer = { id:string; view:MessageView; content?:React.ReactNode };
export function MultiViewEditor({ layers, onChangeLayer, onCommitNewView, onReorderLayers, selection:extSel, onSelectionChange }:{ layers:Layer[]; onChangeLayer:(id:string,next:Partial<MessageView>)=>void; onCommitNewView:(id:string)=>Promise<void>|void; onReorderLayers:(ids:string[])=>void; selection?:string[]; onSelectionChange?:(ids:string[])=>void; }){
  const [selectionState,setSelectionState]=useState<string[]>(extSel??[]); const [smartSnap,setSmartSnap]=useState(true); const [baseline,setBaseline]=useState(false);
  const sel = extSel ?? selectionState; const setSel = onSelectionChange ?? setSelectionState;
  function align(mode:any){ if(sel.length<2) return; const rect=(id:string)=>{ const L=layers.find(l=>l.id===id)!; const lay=L.view.layout||{}; return { id, x:lay.x??0, y:lay.y??0, w:lay.w??320, h:lay.h??200 }; }; const rs=sel.map(rect); const minX=Math.min(...rs.map(r=>r.x)), maxX=Math.max(...rs.map(r=>r.x+r.w)), midX=(minX+maxX)/2; const minY=Math.min(...rs.map(r=>r.y)), maxY=Math.max(...rs.map(r=>r.y+r.h)), midY=(minY+maxY)/2; rs.forEach(r=>{ let x=r.x,y=r.y; if(mode==='left')x=minX; if(mode==='right')x=maxX-r.w; if(mode==='center')x=Math.round(midX-r.w/2); if(mode==='top')y=minY; if(mode==='bottom')y=maxY-r.h; if(mode==='middle')y=Math.round(midY-r.h/2); onChangeLayer(r.id,{ layout:{ ...(layers.find(l=>l.id===r.id)!.view.layout||{}), x,y } as any }); }); }
  function distribute(axis:'h'|'v'){ if(sel.length<3) return; const rects=sel.map(id=>{ const L=layers.find(l=>l.id===id)!; const lay=L.view.layout||{}; return { id, x:lay.x??0, y:lay.y??0, w:lay.w??320, h:lay.h??200 }; }); if(axis==='h'){ const s=rects.sort((a,b)=>a.x-b.x); const min=s[0].x, max=Math.max(...s.map(r=>r.x+r.w)); const total=s.reduce((m,r)=>m+r.w,0); const space=(max-min-total)/(s.length-1); let cursor=s[0].x+s[0].w+space; for(let i=1;i<s.length-1;i++){ const r=s[i]; onChangeLayer(r.id,{ layout:{ ...(layers.find(l=>l.id===r.id)!.view.layout||{}), x:Math.round(cursor - r.w/2) } as any }); cursor+=r.w+space; } } else { const s=rects.sort((a,b)=>a.y-b.y); const min=s[0].y, max=Math.max(...s.map(r=>r.y+r.h)); const total=s.reduce((m,r)=>m+r.h,0); const space=(max-min-total)/(s.length-1); let cursor=s[0].y+s[0].h+space; for(let i=1;i<s.length-1;i++){ const r=s[i]; onChangeLayer(r.id,{ layout:{ ...(layers.find(l=>l.id===r.id)!.view.layout||{}), y:Math.round(cursor - r.h/2) } as any }); cursor+=r.h+space; } } }
  function equalize(what:'w'|'h'|'both'){ if(sel.length<2) return; const ref=layers.find(l=>l.id===sel[0])!; const lay=ref.view.layout||{}; const w=lay.w??320, h=lay.h??200; sel.slice(1).forEach(id=>{ const ll=layers.find(l=>l.id===id)!.view.layout||{}; onChangeLayer(id,{ layout:{ ...ll, w:(what==='w'||what==='both')?w:(ll.w??320), h:(what==='h'||what==='both')?h:(ll.h??200) } as any }); }); }
  function reorder(op:'front'|'back'|'up'|'down'){ if(sel.length===0) return; const ids=layers.map(l=>l.id); const selected=new Set(sel); const remain=ids.filter(id=>!selected.has(id)); let result:string[]=[]; if(op==='front') result=[...remain,...sel]; if(op==='back') result=[...sel,...remain]; if(op==='up'){ result=ids.slice(); for(let i=result.length-2;i>=0;i--){ if(selected.has(result[i])){ const t=result[i]; result[i]=result[i+1]; result[i+1]=t; } } } if(op==='down'){ result=ids.slice(); for(let i=1;i<result.length;i++){ if(selected.has(result[i])){ const t=result[i]; result[i]=result[i-1]; result[i-1]=t; } } } onReorderLayers(result); }
  async function saveSelection(){ for(const id of sel){ await onCommitNewView(id); } }
  return (<div style={{ display:"grid", gridTemplateRows:"auto 1fr", gap:12 }}>
    <CanvasToolbar selection={sel} onAlign={align} onDistribute={distribute} onEqualize={equalize} onReorder={reorder} onGroup={()=>{}} onUngroup={()=>{}} onSaveSelection={saveSelection} onLock={(v)=>sel.forEach(id=>onChangeLayer(id,{ locked:v } as any))} onVisible={(v)=>sel.forEach(id=>onChangeLayer(id,{ visible:v } as any))} smartSnap={smartSnap} setSmartSnap={setSmartSnap} baseline={baseline} setBaseline={setBaseline} />
    <div style={{ position:"relative" }}>
      <SelectionCanvas layers={layers} onChangeLayer={(id,next)=>onChangeLayer(id,next)} onCommitNewView={(id)=>onCommitNewView(id)} onSelectionChange={(ids)=>setSel(ids)} onReorderLayers={(ids)=>onReorderLayers(ids)} smartSnap={smartSnap} baselinePx={20} />
      {baseline && <BaselineOverlay baseline={20} />}
    </div>
  </div>);
}