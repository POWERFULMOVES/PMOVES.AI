{
  "name": "YouTube RAG Pipeline with MCP Tools",
  "nodes": [
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.webhook_url }}",
        "authentication": "none",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook - YouTube URLs",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "youtube-rag-pipeline"
    },
    {
      "parameters": {
        "functionCode": "// Extract and validate YouTube URLs\nconst urls = $input.all()[0].json.urls || [];\nconst validUrls = [];\n\nfor (const url of urls) {\n  const videoIdMatch = url.match(/(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/)([^&\\n]+)/);\n  if (videoIdMatch) {\n    validUrls.push({\n      url: url,\n      videoId: videoIdMatch[1],\n      timestamp: new Date().toISOString()\n    });\n  }\n}\n\nreturn validUrls;"
      },
      "id": "validate_urls",
      "name": "Validate YouTube URLs",
      "type": "n8n-nodes-base.functionItem",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "resource": "customRequest",
        "operation": "custom",
        "method": "POST",
        "url": "http://localhost:8080/mcp/docker/get_video_info",
        "body": "={{ JSON.stringify({ url: $json.url }) }}",
        "headers": {
          "Content-Type": "application/json"
        }
      },
      "id": "get_video_metadata",
      "name": "MCP - Get Video Info",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [650, 200]
    },
    {
      "parameters": {
        "resource": "customRequest",
        "operation": "custom",
        "method": "POST",
        "url": "http://localhost:8080/mcp/docker/get_transcript",
        "body": "={{ JSON.stringify({ url: $json.url, lang: 'en' }) }}",
        "headers": {
          "Content-Type": "application/json"
        }
      },
      "id": "get_transcript",
      "name": "MCP - Get Transcript",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [650, 400]
    },
    {
      "parameters": {
        "functionCode": "// Parse transcript into segments with timestamps\nconst videoData = $input.all()[0].json;\nconst transcript = videoData.transcript || '';\nconst metadata = videoData.metadata;\n\n// Split transcript into sentences\nconst sentences = transcript.match(/[^.!?]+[.!?]+/g) || [];\nconst segments = [];\n\n// Calculate timestamps (150 words per minute average)\nlet currentTime = 0;\nconst wordsPerSecond = 2.5;\n\nsentences.forEach((sentence, index) => {\n  const wordCount = sentence.trim().split(/\\s+/).length;\n  const duration = wordCount / wordsPerSecond;\n  \n  segments.push({\n    video_id: videoData.videoId,\n    segment_id: index,\n    text: sentence.trim(),\n    start_seconds: Math.round(currentTime * 100) / 100,\n    end_seconds: Math.round((currentTime + duration) * 100) / 100,\n    start: new Date(currentTime * 1000).toISOString().substr(11, 12),\n    end: new Date((currentTime + duration) * 1000).toISOString().substr(11, 12),\n    watch_url: videoData.url,\n    timestamped_url: `${videoData.url}&t=${Math.floor(currentTime)}s`,\n    metadata: metadata\n  });\n  \n  currentTime += duration;\n});\n\nreturn segments;"
      },
      "id": "segment_transcript",
      "name": "Segment Transcript",
      "type": "n8n-nodes-base.functionItem",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "model": "sentence-transformers/all-mpnet-base-v2",
        "options": {
          "dimension": 3584
        },
        "text": "={{ $json.text }}"
      },
      "id": "huggingface_embeddings",
      "name": "HuggingFace - Text Embeddings",
      "type": "n8n-nodes-base.huggingFace",
      "typeVersion": 1,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "functionCode": "// Generate CoCa-style contrastive summaries\nconst segments = $input.all();\nconst summaries = [];\n\n// Group segments into semantic chunks (5 segments each)\nfor (let i = 0; i < segments.length; i += 5) {\n  const chunk = segments.slice(i, Math.min(i + 5, segments.length));\n  const combinedText = chunk.map(s => s.json.text).join(' ');\n  \n  // Create contrastive summary\n  const summary = {\n    video_id: chunk[0].json.video_id,\n    chunk_id: Math.floor(i / 5),\n    segments: chunk.map(s => s.json.segment_id),\n    start_seconds: chunk[0].json.start_seconds,\n    end_seconds: chunk[chunk.length - 1].json.end_seconds,\n    text: combinedText,\n    type: 'summary',\n    // This will be used for contrastive learning\n    contrastive_prompt: `Summarize the main concept discussed between ${chunk[0].json.start} and ${chunk[chunk.length - 1].json.end}: ${combinedText.substring(0, 200)}...`\n  };\n  \n  summaries.push(summary);\n}\n\nreturn summaries;"
      },
      "id": "create_summaries",
      "name": "Create CoCa Summaries",
      "type": "n8n-nodes-base.functionItem",
      "typeVersion": 1,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "model": "sentence-transformers/all-mpnet-base-v2",
        "options": {
          "dimension": 3584
        },
        "text": "={{ $json.contrastive_prompt }}"
      },
      "id": "huggingface_summary_embeddings",
      "name": "HuggingFace - Summary Embeddings",
      "type": "n8n-nodes-base.huggingFace",
      "typeVersion": 1,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "youtube_transcripts",
        "columns": "video_id,segment_id,text,start_seconds,end_seconds,timestamped_url,text_embedding",
        "values": "={{ $json.video_id }},={{ $json.segment_id }},={{ $json.text }},={{ $json.start_seconds }},={{ $json.end_seconds }},={{ $json.timestamped_url }},={{ $json.embedding }}"
      },
      "id": "supabase_insert_segments",
      "name": "Supabase - Insert Segments",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1450, 200]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "youtube_summaries",
        "columns": "video_id,chunk_id,summary_text,start_seconds,end_seconds,summary_embedding,segment_ids",
        "values": "={{ $json.video_id }},={{ $json.chunk_id }},={{ $json.text }},={{ $json.start_seconds }},={{ $json.end_seconds }},={{ $json.embedding }},={{ JSON.stringify($json.segments) }}"
      },
      "id": "supabase_insert_summaries",
      "name": "Supabase - Insert Summaries",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1450, 400]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "youtube_metadata",
        "columns": "video_id,title,description,uploader,thumbnail_url,watch_url,processed_at",
        "values": "={{ $json.videoId }},={{ $json.metadata.title }},={{ $json.metadata.description }},={{ $json.metadata.uploader }},={{ $json.metadata.thumbnail }},={{ $json.url }},={{ $json.timestamp }}"
      },
      "id": "supabase_insert_metadata",
      "name": "Supabase - Insert Metadata",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1450, 600]
    },
    {
      "parameters": {
        "functionCode": "// Hybrid Search Query Builder\nconst searchQuery = $input.all()[0].json.query;\nconst searchType = $input.all()[0].json.searchType || 'hybrid';\n\nconst queries = {\n  // Dot product similarity search on embeddings\n  vector: `\n    SELECT \n      t.*, \n      1 - (t.text_embedding <=> $1) as similarity\n    FROM youtube_transcripts t\n    ORDER BY similarity DESC\n    LIMIT 10\n  `,\n  \n  // Keyword search using pg_trgm\n  keyword: `\n    SELECT \n      t.*,\n      similarity(t.text, $1) as text_similarity\n    FROM youtube_transcripts t\n    WHERE t.text % $1\n    ORDER BY text_similarity DESC\n    LIMIT 10\n  `,\n  \n  // Hybrid search combining both\n  hybrid: `\n    WITH vector_search AS (\n      SELECT \n        video_id, segment_id,\n        1 - (text_embedding <=> $1) as vector_score\n      FROM youtube_transcripts\n      ORDER BY vector_score DESC\n      LIMIT 20\n    ),\n    keyword_search AS (\n      SELECT \n        video_id, segment_id,\n        similarity(text, $2) as keyword_score\n      FROM youtube_transcripts\n      WHERE text % $2\n      ORDER BY keyword_score DESC\n      LIMIT 20\n    )\n    SELECT \n      t.*,\n      COALESCE(v.vector_score, 0) * 0.7 + \n      COALESCE(k.keyword_score, 0) * 0.3 as combined_score\n    FROM youtube_transcripts t\n    LEFT JOIN vector_search v USING (video_id, segment_id)\n    LEFT JOIN keyword_search k USING (video_id, segment_id)\n    WHERE v.vector_score IS NOT NULL OR k.keyword_score IS NOT NULL\n    ORDER BY combined_score DESC\n    LIMIT 10\n  `\n};\n\nreturn {\n  query: queries[searchType],\n  searchQuery: searchQuery,\n  searchType: searchType\n};"
      },
      "id": "hybrid_search_builder",
      "name": "Hybrid Search Query Builder",
      "type": "n8n-nodes-base.functionItem",
      "typeVersion": 1,
      "position": [1650, 300]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [[{"node": "validate_urls", "type": "main", "index": 0}]]
    },
    "validate_urls": {
      "main": [[
        {"node": "get_video_metadata", "type": "main", "index": 0},
        {"node": "get_transcript", "type": "main", "index": 0}
      ]]
    },
    "get_video_metadata": {
      "main": [[{"node": "segment_transcript", "type": "main", "index": 0}]]
    },
    "get_transcript": {
      "main": [[{"node": "segment_transcript", "type": "main", "index": 0}]]
    },
    "segment_transcript": {
      "main": [[
        {"node": "huggingface_embeddings", "type": "main", "index": 0},
        {"node": "create_summaries", "type": "main", "index": 0}
      ]]
    },
    "huggingface_embeddings": {
      "main": [[{"node": "supabase_insert_segments", "type": "main", "index": 0}]]
    },
    "create_summaries": {
      "main": [[{"node": "huggingface_summary_embeddings", "type": "main", "index": 0}]]
    },
    "huggingface_summary_embeddings": {
      "main": [[{"node": "supabase_insert_summaries", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "maxExecutionTimeout": 900
  }
}